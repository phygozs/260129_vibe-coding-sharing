

# **第一次就能跑起来**

  

## **—— AI-Coding 实战分享稿（图书馆预约系统版）**

---

## **一、开场 & 核心理念（约 5 分钟）**

  

在开始之前，我想先抛一个**有点反直觉**的结论。

  

> 虽然今天我们讲的是 AI-Coding，

> 但这场分享的目标，**不是把你变成程序员**。

  

你今天不需要学代码、不需要学语法、也不需要知道什么前端后端。

你只需要会一件事：

  

👉 **把你真正想做的事情，说清楚。**

  

现在的 AI，已经强到一个程度——

**只要你把需求讲清楚，它就能帮你把「想法」变成一个真的能跑起来的东西。**

  

所以，今天这 40 分钟，我想让大家记住的核心金句只有一句：

  

> **让真正懂业务的人，第一次就能把想法直接「跑起来」。**

  

---

### **我们今天不追求什么？**

  

先说清楚三件**不追求**的事：

- ❌ **不追求长期**
    
    你是业务人员、老师、运营、产品，而不是工程师
    
- ❌ **不追求完美**
    
    第一次交付，只要能用、能判断对错就够
    
- ✅ **追求讲清楚**
    
    跑起来，更形象，而不是“看起来好高级”
    

---

### **AI-Coding 的「甜蜜区」**

  

那 AI-Coding 最适合干什么？

  

我把它总结成三个非常现实的特点：

- **目标是验证**
    
    - 这个需求值不值得做？
        
    - 流程顺不顺？
        
    - 学生 / 用户会不会真的用？
        
    
- **短周期、低成本**
    
    - 半天～几天就能看到结果
        
    - 做坏了，直接丢掉重来
        
    
- **需求可描述**
    
    - 你能说清楚什么算成功，什么算失败
        
    - 哪怕你完全不懂技术
        
    

---

### **AI-Coding 的三条「警示」线**

  

但我必须很负责任地说：

**不是所有的内容都适合用 AI-Coding 来做（可以辅助）。**

  

⚠️三条「警示」线：

1. **核心业务系统**
    
    - 真实交易
        
    - 计费、学籍、权限核心链路
        
    
2. **长期运行系统**
    
    - 要稳定跑 3–5 年
        
    - 多人长期维护
        
    
3. **高风险场景**
    
    - 高并发
        
    - 高安全
        
    - 高合规
        
    

  

### **为什么？**

  

> **AI 更擅长「拼装」，而不是「打地基」。**

  
- 很适合快速做一个「能用的样子」，但如果要用很多年、不断升级，相当于让临时老师带主课程，后面接手、维护都会很吃力。
    
- 在验证阶段用 AI 快速跑一轮，就像先做一次公开课或内测班；一旦发现不合适，可以马上调整，而不是等正式上线后再推倒重来。
    
- 前期没有清晰结构和标准，后期会变成“没人敢改、没人能接”的系统，就像没有统一教案的课程，越教越乱

---

### **现场判断练习**

  

```
# 选择题目类型

quiz_type = st.radio(

"选择题目类型：",

["基础题（明确适合/不适合）", "进阶题（灰区判断）"],

horizontal=True

)

if quiz_type == "基础题（明确适合/不适合）":

scenarios = {

"做一个内部数据看板，验证团队是否真的需要": "✅ 适合",

"开发公司核心 ERP 系统": "❌ 不适合",

"临时活动报名页面（活动结束就下线）": "✅ 适合",

"客户数据管理系统（长期使用）": "❌ 不适合",

"做一个新审批流程演示，让 10 个人试用找卡点": "✅ 适合",

"公司官网的在线客服系统（7×24 小时）": "❌ 不适合"

}

for scenario, answer in scenarios.items():

col1, col2, col3 = st.columns([3, 1, 1])

with col1:

st.write(f"**{scenario}**")

with col2:

if st.button("适合", key=f"yes_{scenario}"):

if answer == "✅ 适合":

with col3:

st.success("✅ 正确")

else:

with col3:

st.error("❌ 错误")

with col3:

if st.button("不适合", key=f"no_{scenario}"):

if answer == "❌ 不适合":

with col3:

st.success("✅ 正确")

else:

with col3:

st.error("❌ 错误")

else: # 进阶题（灰区判断）

st.info("💡 **这些场景需要你判断如何收束范围，才能用 vibe-coding**")

gray_scenarios = [

{

"question": "产品/业务方一句话说：我们也要做一个“AI 智能体平台”",

"answer": "❌ 先不适合",

"explanation": "**目标过大过虚，先不适合：**\n- ❌ “平台 / 智能体”本身不是可验证目标\n- ✅ 必须先拆成具体动作：比如“帮课程运营自动生成跟练任务”\n- ✅ 每次只选一个高频、低风险、可 1–2 天验证的场景\n- ✅ 用 vibe-coding 验证“是否真有用”，而不是“看起来很先进”"

},

{

"question": "基于公司真实业务数据做内部 AI 分析 / 决策 / 助手工具",

"answer": "⚠️ 视情况而定",

"explanation": "**关键看数据和影响范围：**\n- ✅ 如果是脱敏数据、汇总数据、样本数据：可以先做验证\n- ❌ 如果涉及客户隐私、收入、合同、关键决策链路：不适合直接用\n- ✅ 更优路径：先用假数据或影子数据验证分析逻辑是否有价值\n- ⚠️ 一旦进入真实业务决策，必须引入工程与安全评估"

},

{

"question": "做一个团队内部用的知识库/文档整理工具",

"answer": "✅ 适合",

"explanation": "**适合，但要明确使用周期：**\n- ✅ 验证阶段：快速做一个，看团队是否真的会用\n- ✅ 如果只用 1-2 个月：vibe-coding 可以撑住\n- ⚠️ 如果要长期使用（1年+）：验证后交给研发重构\n- ✅ 关键是：先验证价值，再决定投入"

}

]

for i, scenario in enumerate(gray_scenarios):

st.markdown(f"#### 场景 {i+1}：{scenario['question']}")

col1, col2 = st.columns([1, 1])

with col1:

if st.button("查看答案", key=f"gray_{i}"):

with col2:

if scenario['answer'].startswith("✅"):

st.success(f"**{scenario['answer']}**")

elif scenario['answer'].startswith("❌"):

st.error(f"**{scenario['answer']}**")

else:

st.warning(f"**{scenario['answer']}**")

st.markdown(scenario['explanation'])  
```
---

## **二、AI-Coding 的方式：到底选哪种？（约 5 分钟）**

  

AI- Coding有三种方式： prompt \ vibe1.0 \ vibe2.0(spec)

  

那到底怎么选，我教大家一个**一刀切**的判断问题：

  

> **需不需要把“规则写出来“，决定了你用哪一层 AI-Coding。**

    

从这一刀下去，三种方式自然分开：

- **Prompt-Coding**
    
    - 只看结果像不像
        
    
- **Vibe-Coding 1.0**
    
    - 我要 AI **严格按我定的规则跑**
        
    
- **Vibe-Coding 2.0**
    
    - 规则从prompt里拆出来，单独存放、反复使用、不被改写
        
    


---

## **三、Prompt-Coding：一句话 AI 自己跑（约 7 分钟）**

  

### **1、什么是 Prompt-Coding？**

  

一句话定义：

  

> **我把需求说清楚，AI 直接给我一个「看起来能用」的结果。**

  

特点很明显：

- 不写代码
    
- 不管怎么算
    
- 错了就重来，成本极低
    

  

你可以把 AI 当成一个：

  

👉 **反应极快、不会嫌你烦的展示助手。**

---

### **2、什么场景适合 Prompt-Coding？**

  

判断标准非常简单：

  

> **我能不能凭直觉判断这个结果好不好？**

  

如果能，那就适合 Prompt-Coding。

  

所以我经常说一句话：

  
> **80% 的日常工作，其实用 Prompt-Coding 就够了。**

  

比如：

- 页面文案顺不顺
    
- 流程说明清不清楚
    
- Demo 页面好不好看
    

---

### **3、示例：图书馆预约展示页面**

  

**第一步，生成文案**

不是让AI「自己想」，而是利用「提示词」提供**清楚的业务事实**：

- 开放对象：学生 
    
- 可预约时间段
    
- 一些基本预约规则的说明
    

  

同时加上明确约束：

- 不用「智能推荐」
    
- 一条规则一句话
    

  

👉 这一步，**你是业务专家，不要让 AI 自由发挥情绪，要约束结构。**

  

**第二步，生成 Prompt-coding的指令（Prompt 套 Prompt）。**

最简提示词：

- 根据下方prompt（粘贴在对话的最下面）
    
- 生成互动式的html网页的vibe-coding提示词（简要描述应用的形式）
    
- 强化“涟漪”视觉导向（描述视觉偏好或其他偏好，非必需）  



👉 这一步，**“用AI，放大你已经做对的事情”。**



**第三步，用工具把页面跑出来。**

  

你会很快看到一个：

- 能点
    
- 能看
    
- 能演示流程的页面
    

---

### **4️⃣ Prompt-Coding 的止损线**

  

我们做对了什么？

  

> **把已知信息，表达到位。



一旦你开始关心这些问题：

- 「这个时间段会不会被重复预约？」
    
- 「名额到底算不算占用？」
    

  

**立刻停。**

  

这不是 Prompt-coding 能够实现的问题，

是场景升级了。

  

---

## **四、Vibe-Coding 1.0：按我定的规则跑（约 15 分钟）**

  

从这里开始，你第一次不再是：

  

> 「祈祷 AI 足够聪明」

  

而是变成：

  

> **规则制定者。**

---

### **1、锁目标（80% 的成败在这里）**

  
很多人一上来会说：

  

> “帮我做一个图书馆预约系统。”

  

这句话对 AI 来说是灾难级输入。

  

为什么？

因为它**同时模糊了三件最关键的事**。

  

我们逐条把它锁死。

---

#### **① 明确解决什么问题（不能模糊）**

  

❌ 模糊说法：

  

> 帮我做一个预约管理系统

  

✅ 清晰说法（示例）：

  

> 需要一个工具，让读者能快速看到今天还能预约的参观时间，并完成预约。

  

注意这个改写里发生了什么变化：

- 不再说“系统”，而是**明确目标任务**
    
- 明确是 **查看可预约时间**
    
- 明确是 **提交预约操作**
    

  

👉 这一步的目的只有一个：

  

**把“系统功能”翻译成“具体可执行的操作任务”。**

---

#### **② 什么是成功？什么算失败？（必须可判断）**

  

❌ 错误定义：

  

> 系统看起来完整

> 功能比较多

> 可以用

  

这些对 AI 来说，**全部是空气**。

  

✅ 可执行定义（示例）：

- **成功**：
    
    - 打开页面就能看到当天可预约的时间段
        
    - 可以轻松找到空闲时间，不用猜测
        
    - 能一键完成预约，并显示确认信息
        
    
- **失败**：
    
    - 打开页面后找不到可预约时间
        
    - 点击预约后没有确认信息
        
    - 需要多次点击或返回才能完成一次预约
        
    

  

一句话总结这一步：

  

> **成功与失败，必须是“能直观检查”的状态。**

---

#### **③ 明确哪些不能做（最重要的一条）**

  

这一条**决定你是不是在做 Vibe-Coding 1.0**。

  

如果你不写清楚，

AI 一定会“好心”帮你多做事。

  

在图书馆预约系统里，**必须明确禁止**：

- ❌ 不做读者注册/登录
    
- ❌ 不做图书馆管理员管理功能
    
- ❌ 不做统计或报表
    
- ❌ 不自行补充复杂规则（如限制预约次数、推荐时间段）
    

  

👉 **不允许做什么，比允许做什么更重要。**

---

### **2、拆小步（让 AI 一次只干一件事）**

  

目标锁完之后，

第二个常见错误是：“那你帮我把整个预约流程都做了吧”或“帮我做一个预约系统”。

  

这在 Vibe-Coding 1.0 里**是绝对不允许的**。

---

#### **核心原则**

  

> **一次，只允许 AI 做一件小事情。**

  

你不是在“指挥一个聪明助手”，

而是在**使用一个严格执行步骤的计算器**。

---

#### **把“预约”拆成 AI 不会误解的步骤**

  

✅ 可执行拆法（示例）：

  

**Step 1：整理固定信息**

- 今天的开放时间
    
- 可预约的参观人数
    
- 不预测变化，只做结构化整理
    

  

**Step 2：输入可预约时间段清单**

- 例如 9:00-10:00、10:00-11:00
    
- 不比较，只做列表展示
    

  

**Step 3：展示给读者**

- 显示可预约时间段
    
- 每个时间段加“预约”按钮
    
- 不处理预约，只显示信息
    

  

**Step 4：提交预约**

- 点击按钮提交预约
    
- 弹出确认信息
    
- 不解读，只输出结果
    

  

**Step 5：显示预约结果**

- 显示预约成功或失败
    
- 不推荐最佳时间，只显示状态
    


锁目标+拆小步的代码翻译：
```
elif page == "🔧 正确使用姿势":
    st.title("用 Vibe-Coding 的正确姿势")
    
    # 核心原则
    st.markdown("### 🔑 核心原则")
    st.success("""
    ## 人负责想清楚，AI 负责执行
    
    ⚠️ AI 最大的问题不是笨，而是——**太爱替你做决定**
    """)
    
    st.markdown("---")
    
    # 两步法
    st.markdown("### 📋 两步法（极简版）")
    
    # 创建交互式流程
    step = st.selectbox(
        "选择步骤查看详情：",
        ["概览", "第一步：先锁目标（人做）", "第二步：拆小步（人做）"]
    )
    
    if step == "概览":
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("""
            <div class="highlight-box">
            <h3 style="text-align: center;">1️⃣ 先锁目标</h3>
            <p>想清楚要什么<br>更重要的是<b>不要什么</b></p>
            </div>
            """, unsafe_allow_html=True)
        
        with col2:
            st.markdown("""
            <div class="highlight-box">
            <h3 style="text-align: center;">2️⃣ 拆小步</h3>
            <p>一次只让 AI<br>做<b>一件小事</b></p>
            </div>
            """, unsafe_allow_html=True)
    
    elif step == "第一步：先锁目标（人做）":
        st.markdown("""
        <div class="highlight-box">
        <h3>🎯 第一步：先锁目标</h3>
        <p style="font-size: 18px;">回答三个问题：</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.expander("❓ 1. 我要解决什么问题？"):
            st.write("**反面案例：**")
            st.error("「帮我做一个预约管理系统」（太模糊）")
            st.write("**正面案例：**")
            st.success("「我需要一个工具，让读者能快速看到今天还能预约的参观时间，并完成预约」")
        
        with st.expander("❓ 2. 什么是成功？什么算失败？"):
            st.write("**反面案例：**")
            st.error("「功能完善就是成功」（不直观）")
            st.write("**正面案例：**")
            st.success("""
            **成功标准：**
            - 读者打开页面就能看到当天可预约的时间段
            - 可以轻松找到空闲时间，不需要猜测
            - 能一键完成预约，无需填写太多信息
            
            **失败标准：**
            - 打开页面后，不知道哪些时间还能预约
            - 点击预约后找不到确认信息
            - 读者必须多次点击或返回才完成预约
            """)
        
        with st.expander("❓ 3. 明确说：哪些不做"):
            st.write("**为什么这个最重要？**")
            st.warning("👉 如果不写清楚，AI 会自己加功能或流程，反而复杂")
            st.write("**正面案例：**")
            st.success("""
            **这个版本不做：**
            - ❌ 不做读者注册/登录
            - ❌ 不做图书馆管理员管理功能
            - ❌ 不做统计或报表
            - ❌ 只做查看可预约时间和提交预约，其他都不做
            """)
    
    elif step == "第二步：拆小步（人做）":
        st.markdown("""
        <div class="highlight-box">
        <h3>🔨 第二步：拆小步</h3>
        </div>
        """, unsafe_allow_html=True)
        
        st.warning("### ❌ 不要说：")
        st.code('"帮我做一个图书馆预约管理系统"', language=None)
        
        st.success("### ✅ 而是：")
        
        # 互动式拆解示例
        tasks = [
            "第 1 步：先有一个页面，显示「图书馆预约系统」标题",
            "第 2 步：显示今天可预约的 3 个时间段",
            "第 3 步：每个时间段加一个「预约」按钮",
            "第 4 步：点击按钮弹出预约确认信息",
            "第 5 步：预约后显示预约成功提示"
        ]
        
        completed = []
        for i, task in enumerate(tasks):
            if st.checkbox(task, key=f"task_{i}"):
                completed.append(i)
        
        if completed:
            progress = len(completed) / len(tasks)
            st.progress(progress)
            st.write(f"已完成：{len(completed)}/{len(tasks)} 步")
        
        st.markdown("---")
        st.info("""
        ### 💡 核心原则：
        # 一次只允许 AI 做一件小事
        
        为什么？
        - 每一步都能验证
        - 出错了容易定位
        - 可以随时调整方向
        """)
```


我特别想强调一句话：

  

> **拆得越细，AI 越像计算器，你越像决策者。**

  

这就是 Vibe-Coding 1.0 的精髓。


#### **3、分组研讨环节（约 5–7 分钟）**

  

**目标**：练习“锁目标 + 拆小步”的逻辑，形成提示词。

  

**规则**：

1. **分组**：每组xx人，业务背景相同
    
2. **选择一个简单业务场景**
    
3. **步骤**：
    
    1. 每组先明确**目标任务**（不能模糊），写一句话描述：
            
        
    2. 明确**成功与失败**：
        
        - 每组列出 2–3 条“能直观判断成功/失败”的标准
            
        
    3. 明确**禁止事项**：
        
        - 列出至少 3 项不允许 AI 做的事情
            
        
    4. **拆小步**：
        
        - 把目标任务拆成 3–5 个最小执行步骤
            
        
    
4. **输出**：每组形成一个简单提示词（文字形式即可，不用 AI 工具）
    

  

**讨论要点**：

- 这个目标是不是清晰？
    
- 成功/失败标准能否直观判断？
    
- 拆的小步 AI 是否能够独立执行？
    

  
---

## **五、Vibe-Coding 2.0：规则从 prompt 中拆出，形成可复用判断（约 5 分钟）**

  

### **1、为什么要 2.0？**

  

在 1.0 阶段，我们已经做对了两件事：

1. 人先想清楚目标、成功/失败、禁止行为，
    
2. AI 严格按规则执行，不替人做决定
    

只要你能够想清楚这些，其实你已经站在 1.0 的**「天花板」**上了。

  
在 1.0 阶段，我们通常是这样做的：

- 把页面怎么展示写在 prompt 里
    
- 把流程写在 prompt 里
    
- 顺便把特殊规则也写在 prompt 里
    

  

一开始完全没问题，甚至非常高效。

  

但慢慢你会发现三件事：

1. **判断变多了**
    
    原来只有“满不满”，后来又多了“是否超时”“是否重复”
    
2. **判断开始复用**
    
    不只是一个按钮在用，多个页面、多个流程都会用到同一套判断
    
3. **判断开始互相影响**
    
    改一个规则，别的地方的结果也会变
    

  

这时候你会有一个非常真实的感受：

> 我不会写 prompt了么？

> **其实是 prompt 开始装不下这些判断了，**

> **2.0 不是让你写更复杂的东西，而是承认：有些判断，不适合继续放在 prompt 里了。**


### **2.0 做的第一件事：把“影响对错的句子”拆出来**

  

在图书馆预约这个例子中，有一类句子很特殊：

- 能不能预约？
    
- 为什么不能预约？
    
- 成功和失败是怎么判定的？
    

  

这些句子有一个共同点：

  

> **它们不决定页面长什么样，**

> **只决定结果对不对。**

  

在 2.0 里，这类句子不再和页面描述混在一起，而是被**单独拎出来**。

---

### **第二件事：把判断写成 Spec**

    

> **Spec 就是一份“防止判断被改写的说明书”。**

  

在 2.0 里，我们不再用一句话说：

  

> “判断这个时间段能不能预约”

  

而是把它固定成一个形态，比如：

- 输入是什么（时间段、当前时间、已有预约）
    
- 输出是什么（成功 / 失败 + 原因）
    
- 哪些情况一定失败
    
- 明确说：不要推荐、不补规则、不加判断
    

  

**一旦写成这种形态，判断就不再依赖 AI 的“理解能力”，**

**而是有了边界。**

---

### **第三件事：把 Spec 放进 IDE（让判断有“房间”）**

  
  

你可以把 IDE （集成开发环境）理解成让“规则有自己房间”的地方：

我们可以用图书馆预约的例子来解释：

1. **页面在一个房间**
    
    - 页面负责展示时间段、按钮、交互效果
        
    - 例如：用户看到 9:00–10:00 还能预约，并能点击“预约”按钮
        
    
2. **判断规则在另一个房间**
    
    - 判断规则负责回答“能不能预约”
        
    - 例如：9:00–10:00 已经被预约满了 → 失败
        
    - 这里的规则独立存放，不随页面改动而改
        
    
3. **页面只能“用”规则，不能“改”规则**
    
    - 页面调用规则来判断是否可预约
        
    - 页面不需要关心规则怎么写、规则里面有哪些判断
        
    - 避免因为页面改动导致规则逻辑被误改

  

---
### **什么时候你真的需要 2.0？**

  

一个**非常可操作的判断标准**：

  

只问自己一句话：

  

> **我是不是已经在 prompt 里，**

> **反复强调同一批判断，**

> **生怕 AI 哪次“理解错”？**

  

- 如果还没有 → 1.0 完全够用
    
- 如果已经是了 → 你其实已经走到 2.0 门口了
    


---
## **六、分享总结 & 金句**

  

> **让真正懂业务的人，第一次就能跑起来——这是 AI-Coding 的核心。**


> 我能凭直觉判断这个结果好坏，就用prompt-coding（解决80%问题）


> 对于vibe-coding：拆得越细，AI 越像计算器，你越像决策者


> 在 prompt 里反复强调同一批判断生怕AI错了，进阶2.0




